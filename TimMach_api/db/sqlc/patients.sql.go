// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: patients.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPatientsByUser = `-- name: CountPatientsByUser :one
SELECT COUNT(*) FROM patients WHERE user_id = $1
`

func (q *Queries) CountPatientsByUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countPatientsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPatient = `-- name: CreatePatient :one
INSERT INTO patients (user_id, name, gender, dob)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, name, gender, dob, created_at
`

type CreatePatientParams struct {
	UserID string      `json:"user_id"`
	Name   string      `json:"name"`
	Gender int16       `json:"gender"`
	Dob    pgtype.Date `json:"dob"`
}

func (q *Queries) CreatePatient(ctx context.Context, arg CreatePatientParams) (Patient, error) {
	row := q.db.QueryRow(ctx, createPatient,
		arg.UserID,
		arg.Name,
		arg.Gender,
		arg.Dob,
	)
	var i Patient
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Gender,
		&i.Dob,
		&i.CreatedAt,
	)
	return i, err
}

const deletePatient = `-- name: DeletePatient :exec
DELETE FROM patients
WHERE id = $1
`

func (q *Queries) DeletePatient(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePatient, id)
	return err
}

const getPatientByID = `-- name: GetPatientByID :one
SELECT id, user_id, name, gender, dob, created_at FROM patients
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPatientByID(ctx context.Context, id int64) (Patient, error) {
	row := q.db.QueryRow(ctx, getPatientByID, id)
	var i Patient
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Gender,
		&i.Dob,
		&i.CreatedAt,
	)
	return i, err
}

const listPatientsByUser = `-- name: ListPatientsByUser :many
SELECT id, user_id, name, gender, dob, created_at FROM patients
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPatientsByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListPatientsByUser(ctx context.Context, arg ListPatientsByUserParams) ([]Patient, error) {
	rows, err := q.db.Query(ctx, listPatientsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Patient
	for rows.Next() {
		var i Patient
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Gender,
			&i.Dob,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatientsWithLatestPrediction = `-- name: ListPatientsWithLatestPrediction :many
WITH pa AS (
    SELECT id, user_id, name, gender, dob, created_at
    FROM patients
    WHERE user_id = $1
),
latest AS (
    SELECT DISTINCT ON (pr.patient_id)
        pr.patient_id,
        pr.probability,
        pr.risk_label,
        pr.created_at
    FROM predictions pr
    JOIN pa ON pa.id = pr.patient_id
    ORDER BY pr.patient_id, pr.created_at DESC
)
SELECT
    p.id,
    p.user_id,
    p.name,
    p.gender,
    p.dob,
    p.created_at,
    l.probability AS latest_probability,
    l.risk_label AS latest_risk_label,
    l.created_at AS latest_prediction_at
FROM pa p
LEFT JOIN latest l ON l.patient_id = p.id
WHERE ($4 = '' OR COALESCE(l.risk_label, 'none') = $4)
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListPatientsWithLatestPredictionParams struct {
	UserID  string      `json:"user_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
	Column4 interface{} `json:"column_4"`
}

type ListPatientsWithLatestPredictionRow struct {
	ID                 int64              `json:"id"`
	UserID             string             `json:"user_id"`
	Name               string             `json:"name"`
	Gender             int16              `json:"gender"`
	Dob                pgtype.Date        `json:"dob"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	LatestProbability  *float64           `json:"latest_probability"`
	LatestRiskLabel    *string            `json:"latest_risk_label"`
	LatestPredictionAt pgtype.Timestamptz `json:"latest_prediction_at"`
}

func (q *Queries) ListPatientsWithLatestPrediction(ctx context.Context, arg ListPatientsWithLatestPredictionParams) ([]ListPatientsWithLatestPredictionRow, error) {
	rows, err := q.db.Query(ctx, listPatientsWithLatestPrediction,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPatientsWithLatestPredictionRow
	for rows.Next() {
		var i ListPatientsWithLatestPredictionRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Gender,
			&i.Dob,
			&i.CreatedAt,
			&i.LatestProbability,
			&i.LatestRiskLabel,
			&i.LatestPredictionAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePatient = `-- name: UpdatePatient :one
UPDATE patients
SET
    name = COALESCE($2, name),
    gender = COALESCE($3, gender),
    dob = COALESCE($4, dob)
WHERE id = $1
RETURNING id, user_id, name, gender, dob, created_at
`

type UpdatePatientParams struct {
	ID     int64       `json:"id"`
	Name   string      `json:"name"`
	Gender int16       `json:"gender"`
	Dob    pgtype.Date `json:"dob"`
}

func (q *Queries) UpdatePatient(ctx context.Context, arg UpdatePatientParams) (Patient, error) {
	row := q.db.QueryRow(ctx, updatePatient,
		arg.ID,
		arg.Name,
		arg.Gender,
		arg.Dob,
	)
	var i Patient
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Gender,
		&i.Dob,
		&i.CreatedAt,
	)
	return i, err
}
